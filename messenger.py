import random
from sha3_512 import SHA3_512
from P521 import P521, point
from simon import Simon
import requests
from point_decompression import compress, decompression
random.seed(234)

def write_to_aws(message, name):
    """
    Writes file to AWS
    """
    f = open(name + ".txt", "w")
    f.write(message)
    f.close()
    data = {"key": name + ".txt"}
    files = {"file": open(name + ".txt", "rb")}
    r = requests.post("NEEDS URL", data=data, files=files)
    return r.status_code

def read_from_aws(name):
    """
    can pull file from aws
    """
    r = requests.get("NEEDS URL" + name+ ".txt")
    return (r.text)

def write_to_file(message, name):
    """
    Writes file
    """
    f = open(name + ".txt", "w")
    f.write(message)
    f.close()

def read_from_file(name):
    """
    Reads file
    """
    f = open(name + ".txt", "r")
    cipher = f.read()
    f.close()
    return cipher

#Message and system parameters

def gen_keys():
    ec = P521()
    priv = random.getrandbits(256)
    pub = ec.double_and_add(priv, ec.P, ec.p)
    return priv, pub

priv_a , pub_A = gen_keys()
priv_x , pub_X = gen_keys()
priv_b , pub_B = gen_keys()
# print(pub_A)

#key and "plain-text" for simon
def simon_input(s,r, A_prime, message, x, B):
    r = (hex(r)[2:]).zfill(132)
    s = (hex(s)[2:]).zfill(132)
    message = [hex(ord(i))[2:] for i in message]
    message = ''.join(message)
    c1 = r + s + A_prime + message                                #"plain_text" input
    # print("r,s, a+m", len(r) , len(s) , len(A_prime),len(message) )
    ec = P521()
    key = ec.double_and_add(x, B, ec.p)
    key  = (hex(key.x)[2:])
    key = key[-64:]                                     #key for simon
    return key, c1


def key_stream(key, ctr_list):
    """
    Key Material generated by Simon for CTR Protocol
    """
    keys = []
    for i in range(1,len(ctr_list)+1):
        S = Simon(key) #64 bit key that is the x coordinate value of agreed k
        input = (hex(i)[2:]).zfill(32)
        k = S.encrypt(input)
        keys.append(k) #keys are 128 bits that get XORed with each block

    # remove the extra keystream for the MSB block
    keys[0] = keys[0][-len(ctr_list[0]):]
    return keys


def create_cipher_text(key, plain_text):
    """
    CTR Protocol
    """
    counter_mode_input = []
    cipher = ""
    for i in range(len(plain_text), 0, -32):            #seperate into blocks (first block usually not 32)
        if i - 32 >= 0:
            counter_mode_input.append(plain_text[i-32:i])
        else:
            counter_mode_input.append(plain_text[0:i])
    counter_mode_input.reverse()
    key_list = key_stream(key, counter_mode_input)

    for i in range(len(counter_mode_input)):
        #xor 64bit keys from simon key stream with each bloack of the plain text.
        new_block = int(key_list[i],16) ^ int(counter_mode_input[i],16)
        if i > 0:
            new_block = (str(hex(new_block)[2:].zfill(32)))
        else:
            new_block = (str(hex(new_block)[2:]))
        cipher = cipher + new_block
    return cipher


def message(message, name = None, new_priv_a = None):
    """
    Function For full secure message encryption.
    If file name is present, it will write cipher text locally or to AWS
    Stores next private Key.
    """
    #create a' (next key to be used: Key Ratcheting)
    A_prime_priv, A_prime_pub = gen_keys()
    A_prime = compress(A_prime_pub)

    # print("Aprine", len(A_prime))
    A_prime_message = A_prime + message

    #hash of the message
    h_m = SHA3_512(A_prime_message)                                 #sha3 consumes text, produces hex string

    #signature from the hash
    signer = P521()                                         #create signer module
    if new_priv_a != None:
        # print("private a used:", new_priv_a)
        signer.set_private_x(new_priv_a)
    else:
        # print("private a used:", priv_a)
        signer.set_private_x(priv_a)                            #set private x, to be senders private key
    # print("next private a to used:", A_prime_priv)
    s, r = signer.create_sig(h_m)                           #create a signature with the above private x

    #simon
    s_key, s_plain_text = simon_input(s,r, A_prime, message, priv_x, pub_B)
    cipher = create_cipher_text(s_key, s_plain_text)

    #create x'
    X_prime = compress(pub_X)
    cipher_X = X_prime + cipher

    if name != None:
        # write_to_aws(cipher_X, name)
        write_to_file(cipher_X, name)
        return "Success", A_prime_priv
    else:
        return cipher_X, A_prime_priv




def received_message(cipher_X, name = None, A_prev = None):
    """
    After key material is exchanged.
    Cipher Text is Parsed starting decryption process
    Stores New key material learned in the message
    If name is not None -> it will decrypt contents of file
        - file can be hosted on AWS
    """
    if name != None:
        # cipher_X = read_from_aws(name)
        cipher_X = read_from_file(name)
        print("Cipher Text found in file is:\n")
        print(cipher_X, "\n")
    #recover X
    x_prime = cipher_X[:132]
    cipher_X = cipher_X[132:]
    # print("x", x_prime)
    # print("Compressed X is:", x_prime)
    X = decompression(x_prime)

    #key for simon using agreed x priv b
    ec = P521()
    key = ec.double_and_add(priv_b, X, ec.p)
    k = hex(key.x)[-64:]
    # print("k is:", k)
    #uncover ciphertext
    l = (len(cipher_X))
    cipher_X = create_cipher_text(k, cipher_X)
    cipher_X = cipher_X.zfill(l)

    #receive params (r,s,A', message)
    r = cipher_X[:132]          # r is first 66 bytes
    s = cipher_X[132:264]       # s is next 66 bytes
    # print("r is:", r)
    # print("s is:", s)
    A_prime = cipher_X[264:396]
    # print("A_prime is:", A_prime)
    message = cipher_X[396:]    # message is after r and s

    #find message
    message = bytes.fromhex(str(message)).decode('utf-8')
    print("Recovered Message Decoded:\n", message)

    #check hash
    h_m = SHA3_512(A_prime + message)
    s, r = (int(s,16),int(r,16))
    verifyer = P521()

    #store A_prime for next key
    #use agreed upon A
    if A_prev != None:
        A = decompression(A_prev)
    else: #for  Public A has already been exchanged.
        A = pub_A

    t_f = verifyer.verification( s, h_m, A, r)        #consumes signature (s,r), hash, public X. produces t/f
    print("verification:\n", t_f)
    return A_prime


print("Welcome to Secure Message System:")
print("--- Enter E for Encryption prompt")
print("--- Enter D for Decryption prompt")
print("--- Enter Q to Exit")
user_input = input()
a = None
a_prev = None
while user_input not in ("Q", "q"):
    if user_input in ("E", "e"):
        print("Enter Name of File to Write To:")
        f_name = input()
        print("Enter Message to Encrypt:")
        plain_text = input()
        status, a = message(plain_text, name = f_name, new_priv_a = a)
    elif user_input in ("D", "d"):
        print("Enter Name of File to Read From:")
        f_name = input()
        a_prev = received_message(None, name = f_name, A_prev = a_prev)

    print(status, ", Enter another Command:")
    user_input = input()







###########
